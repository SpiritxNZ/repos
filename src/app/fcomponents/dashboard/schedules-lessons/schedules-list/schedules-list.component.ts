import { LOCAL_STORAGE } from '@ng-toolkit/universal';
import { Component, OnInit, Input, Output, EventEmitter, Inject, PLATFORM_ID } from '@angular/core';
import { MatDialog, MatDialogRef } from '@angular/material';
import { FormControl } from '@angular/forms';
import { CalendarSupportService } from '../../../../services/support/calendar-support.service';
import { LearnerService } from '../../../../services/servercalls/learner.service';
import { GeneralService } from '../../../../services/servercalls/general.service';
import { TutorService } from '../../../../services/servercalls/tutor.service';
import { SessionEditDialogComponent } from '../../dashboard-dialogs/session-edit-dialog/session-edit-dialog.component';
import { TutorReportDialogComponent } from '../../dashboard-dialogs/tutor-report-dialog/tutor-report-dialog.component';
import * as moment from 'moment';
import { CancelSessionDialogComponent } from '../../dashboard-dialogs/cancel-session-dialog/cancel-session-dialog.component';
import { ReportSessionIssueDialogComponent } from '../../dashboard-dialogs/report-session-issue-dialog/report-session-issue-dialog.component';
import { LearnerSessionRatingDialogComponent } from '../../dashboard-dialogs/learner-session-rating-dialog/learner-session-rating-dialog.component';
import { isPlatformBrowser } from '@angular/common';
import { CommonSupportService } from '../../../../services/support/common-support.service';
import { MessengerHelperService } from '../../../../services/helpers/messenger-helper.service';
import { AlertNotificationService } from '../../../../services/support/alert-notification.service';
import {NgbModule} from '@ng-bootstrap/ng-bootstrap';
@Component({
  selector: 'app-schedules-list',
  templateUrl: './schedules-list.component.html',
  styleUrls: ['./schedules-list.component.css']
})
export class SchedulesListComponent implements OnInit {
  developVersion = false;//for test
  sessionsInfo = []; // tutor role and learner role
  range = [];
  now: any;
  showEdit = false;
  mySessions = []; // store the session generated by fullcalender
  calendarEvents = []; // tutor role
  locations = []; // tutor role
  myLocations = []; // learner role: store location object with tutor id
  freeEvents = []; // learner role: store freeEvents object with tutor id
  baseUrl = 'http://learnspace.co.nz/api/public/';
  sucSubmit = false;
  
  s_indicatorEvent = false;
  // user can choose the session times
  startDate: any;
  end: any;
  endDate: any;
  timeMes = false;

  pagination: any;
  perPage = 10;

  // See if client is using browser (SSR)
  isBrowser = false;

  role: number;
  static TUTOR = 3;  //role definition
  static LEARNER = 1; //role definition
  static APPLICANT = 2;     //role definition

  tabs: any;
  constructor(
    @Inject(PLATFORM_ID) private platformId,
    @Inject(LOCAL_STORAGE) private localStorage: any,
    private tutorService: TutorService,
    private dialog: MatDialog,
    private searchService: GeneralService,
    private calendarService: CalendarSupportService,
    private learnerService: LearnerService,
    private imageService: CommonSupportService,
    private messengerHelperService: MessengerHelperService,
    private alertservice: AlertNotificationService,
  ) {
    if (isPlatformBrowser(this.platformId)) {
      this.isBrowser = true;
    }
    this.startDate = new FormControl(moment().subtract(30, 'years').format());
    this.end = moment().add(30, 'years');
    this.endDate = new FormControl(this.end.format());
    this.range = [moment().subtract(30, 'years').format().substr(0, 19), this.end.format().substr(0, 19)];
    this.role = Number(localStorage.getItem('lsaWho'));
  }
  ngOnInit() {
    console.log(this.range);
    this.setTabs();
    this.showAllSessions();
  }
  // --------------------- Event trigger methods ---------------------------------------------------
  // user clicks the reschedule button, show fullcalendar
  showFullcalender(event) {
    let sessionID = Number(event.srcElement.id.slice(3));
    console.log(sessionID);
    let selectedSession = this.getSession(this.sessionsInfo, sessionID);
    console.log(sessionID, selectedSession);
    /*when user clicks edit button, add the session times to free events firstly, if the user didn't
    change the time, then remove free time when user clicks cancel button on the dialog */
    let times = selectedSession.session_times;
    let tutorID = selectedSession.tutor_id;
    console.log(tutorID);
    // tutor role: generate dialog and process data after dialog closed
    if (this.role === 3) {
      this.processDialog(selectedSession, this.calendarEvents, this.locations, times, this.role);
    }
    // learner role: generate dialog and process data after dialog closed, must inside the subscribe function
    if (this.role === 1 || this.role === 2) {
      this.getInfoShedules(tutorID, times, selectedSession);
    }
  }
  // user clicks on confirm button
  confirmSession(event) {
    let sessionID = Number(event.srcElement.id.slice(3));
    let data = {
      s_status: 'confirm'
    };
    // update text which is related to html
    // this.updateText(data, sessionID);
    //this.updateStatus(data, this.sessionsInfo, sessionID);
    console.log(sessionID, data, this.role);
    // send to server
    this.sendStatus(sessionID, data, this.role, '');
  }
  // user clicks on cancel button
  cancelSession(event) {
    let sessionID = Number(event.srcElement.id.slice(3));
    let data = {
      s_status: 'cancel'
    };
    // get the withinTwelveHours value for the session
    let selectedSession = this.getSession(this.sessionsInfo, sessionID);
    // console.log(sessionID, selectedSession);
    let withinTwelveHours = selectedSession.withinTwelveHours;
    // console.log(sessionID, selectedSession, withinTwelveHours);
    // show confirmation dialog
    let dialogRef = this.dialog.open(CancelSessionDialogComponent,
      {
        panelClass: 'dialog1',
        data: [sessionID, data, withinTwelveHours, this.role],
      });
    dialogRef.afterClosed().subscribe(
      (res) => {
        if (!res) return;
        console.log(res);
        if (res[0] === 'yes') {
          // update text which is related to html
          // this.updateText(data, sessionID);
          //this.updateStatus(data, this.sessionsInfo, sessionID);
          // send to server
          console.log(res);
          let reason = { reason: res[1], suggestion: res[2] }
          this.sendStatus(sessionID, data, this.role, reason);
        }
      },
      (err) => console.warn(err)
    );
  }
  // user click search button
  resetSessions() {
    let start = this.startDate.value;
    let end = this.endDate.value;
    if (moment(end).isSameOrBefore(moment(start))) {
      this.timeMes = true;
    } else {
      // hide warning message
      this.timeMes = false;
      let s_time = moment(start).format().substr(0, 19);
      let e_time = moment(end).format().substr(0, 19);
      // update this.range
      this.range[0] = s_time;
      this.range[1] = e_time;
      console.log(this.range);
      // update sessions
      this.ngOnInit();
    }
  }
  // --------------------- Support Methods ------------------------------------------------------
  // after get the user role, show all sessions
  showAllSessions() {
    console.log(this.range);
    if (this.role === 3) {
      console.log(this.role, 'I am a tutor.');
      // get sessions info
      this.getSessionInfo();
      // get schedules info, used for fullcalendar
      this.getSchedulesInfo();
    }
    if (this.role === 1 || this.role === 2) {
      console.log(this.role, 'I am a learner.');
      this.getLearnerSessionInfo();
      // this.getInfoShedules();
    }
  }
  //set tabs
  setTabs() {
      this.tabs = [{ name: 'All', filter: 'all' },
      { name: 'Planned', filter: '0' },
      { name: 'Completed', filter: '2' },
      { name: 'Canceled', filter: '1' },
      { name: 'waiting rating', filter: '49' },
      { name: 'waiting report', filter: '50' },
      { name: 'Disputed', filter: '3' }
      ];
    //set tab pagination 
    this.pagination = {
      all: { pageNumber: 0, totalPosts: 0, currentPage: 1, pages: [] },
       0:  { pageNumber: 0, totalPosts: 0, currentPage: 1, pages: [] },
       2:  { pageNumber: 0, totalPosts: 0, currentPage: 1, pages: [] },
       1:  { pageNumber: 0, totalPosts: 0, currentPage: 1, pages: [] },
       49: { pageNumber: 0, totalPosts: 0, currentPage: 1, pages: [] },
       50: { pageNumber: 0, totalPosts: 0, currentPage: 1, pages: [] },       
       3:  { pageNumber: 0, totalPosts: 0, currentPage: 1, pages: [] },
    }

  }

  // process dialog fullcalendar
  processDialog(selectedSession: any, calendarEvents: any, locations: any, times: any, role: any) {
    this.addFreetimes(calendarEvents, times);
    // console.log(this.calendarEvents);
    let dialogRef = this.dialog.open(SessionEditDialogComponent,
      {
        panelClass: 'dialog2',
        // data: [1 / 1, this.profile_photo],
        data: [selectedSession, calendarEvents, locations, role],
        // disableClose: true
      });
    dialogRef.afterClosed().subscribe(
      (res) => {
        if (!res) return;
        console.log('Dialog closed now!!!');
        // if it was 1, user clicks cancel button; if 2, user clicks save button but changed nothing
        console.log(res);
        if (res && res !== '1' && res !== '2') {
          console.log(111);
          // 1. remove cancel/confim options
          if (this.isBrowser) {
            this.removeOptions(res[0]);
          }
          // send to server, because res is an array, using utc_session obj
          let id = Object.keys(res[1])[0];
          let data = res[1][id];
          console.log(id, data);
          this.sendTimeLocation(id, data, this.role, res[0]);
        } else {
          // user clicks outside dialog or esc key to close the dialog
          if (res !== '1' && res !== '2') {
            if (role === 3) {
              console.log(this.calendarEvents);
              this.changeTutorEvents(this.calendarEvents);
            }
            if (role === 1 || role === 2) {
              console.log(this.freeEvents);
              this.changeAllTutorEvents(this.freeEvents);
            }
          }
        }
      },
      (err) => console.warn(err)
    );
  }

  //if user cancel and update session ,need send status to server  
  sendStatus(id: any, data: Object, role: any, reason) {
    if (Object.keys(data).length !== 0) {
      if (role === 3) {
        console.log('Now sending status');
        if (data['s_status'] === 'cancel')
          this.tutorService.tutorCancelSession(id, reason).subscribe(
            (res) => {
              // show successfully message
              this.sucSubmit = true;
              console.log(res);
              console.log('Successfully sent data!');
              // update text which is related to html
              // this.updateText(data, sessionID);    
              this.alertservice.sendAlert('This operation succeeded!', 'SUCCESS', 'toast-top-right', 1500);
              //this.updateStatus(data, this.sessionsInfo, id);                        
              this.showAllSessions();
            }
            , (err) => {
              console.warn(err);
              this.alertservice.serviceErrorAlert(err);
              // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
            }
          )
        else
          this.tutorService.updateTutorSessionStatus(id, data).subscribe(
            (res) => {
              // show successfully message
              this.sucSubmit = true;
              console.log(res);
              console.log('Successfully sent data!');
              // update text which is related to html
              // this.updateText(data, sessionID);
              this.alertservice.sendAlert('This operation succeeded!', 'SUCCESS', 'toast-top-right', 1500);
              this.showAllSessions();
            }
            , (err) => {
              console.warn(err);
              this.alertservice.serviceErrorAlert(err);
              // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
            }

          );
      }
      if (role === 1 || role === 2) {
        console.log('post learner update!!!');
        if (data['s_status'] === 'cancel')
          this.learnerService.LearnerCancelSession(id, reason).subscribe(
            (res) => {
              // show successfully message
              this.sucSubmit = true;
              console.log(res);
              console.log('Successfully sent data!');
              // update text which is related to html
              // this.updateText(data, sessionID);     
              this.alertservice.sendAlert('This operation succeeded!', 'SUCCESS', 'toast-top-right', 1500);
              // this.updateStatus(data, this.sessionsInfo, id);
              this.showAllSessions();
            }
            , (err) => {
              console.warn(err);
              // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
              this.alertservice.serviceErrorAlert(err);
            }

          )
        else
          this.learnerService.updateLearnerSessionStatus(id, data).subscribe(
            (res) => {
              // show successfully message
              this.sucSubmit = true;
              console.log(res);
              console.log('Successfully sent data!');
              // update text which is related to html
              // this.updateText(data, sessionID);            
              // this.updateStatus(data, this.sessionsInfo, id);
              this.showAllSessions();
            }
            , (err) => {
              console.warn(err);
              // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
              this.alertservice.serviceErrorAlert(err);
            }

          )
      }
    }
  }
  sendTimeLocation(id: any, data: Object, role: any, para) {
    console.log(data);
    if (Object.keys(data).length !== 0) {
      if (role === 3) {
        this.tutorService.updateTutorSessionTimelocation(id, data).subscribe(
          (res) => {
            // show successfully message
            this.sucSubmit = true;
            console.log(res);
            console.log('Successfully sent data!');
            // 2. update this.sessionInfo because it is connected to the html template,using local session obj
            // this.updateSessions(this.sessionsInfo, para);
            this.showAllSessions();
            console.log(this.sessionsInfo);

            this.alertservice.sendAlert('This operation succeeded!', 'SUCCESS', 'toast-top-right', 1500);
          }
          , (err) => {
            console.warn(err);
            // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
            this.alertservice.serviceErrorAlert(err);
          }
        );
      }
      if (role === 1 || role === 2) {
        console.log('post learner update!!!');
        this.learnerService.updateLearnerSessionTimelocation(id, data).subscribe(
          (res) => {
            // show successfully message
            this.sucSubmit = true;
            console.log(res);
            console.log('Successfully sent data!');
            // 2. update this.sessionInfo because it is connected to the html template,using local session obj
            // this.updateSessions(this.sessionsInfo, para);
            this.showAllSessions();
            console.log(this.sessionsInfo);
            this.alertservice.sendAlert('This operation succeeded!', 'SUCCESS', 'toast-top-right', 1500);
          }
          , (err) => {
            console.warn(err);
            // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
            this.alertservice.serviceErrorAlert(err);
          }
        );
      }
    }
  }
  // change all calendar events to free, because user clicks outside the dialog or esc key,
  // in case he clicks the time and changed the color
  // tutor role:
  changeTutorEvents(events: any[]) {
    for (let event of events) {
      if (event.color === '#00ddff') {
        event.color = '#00ad2b';
      }
    }
  }
  // learner role:
  changeAllTutorEvents(tutors: any[]) {
    for (let tutor of tutors) {
      // as tutor is an object, event only one propery, we need to use for loop to get its value
      // tslint:disable-next-line:forin
      for (let id in tutor) {
        // console.log(tutor[id]);
        this.changeTutorEvents(tutor[id]);
      }
    }
  }
  // tutor role: get tutor sessions information
  getSessionInfo() {
    console.log(this.range);
    this.tutorService.indexTutorSessions(this.range).subscribe((res) => {
      console.log(res);
      let allSessions = res['tutorSessions'];
      console.log(allSessions);
      this.sessionsInfo = this.changeFormat(allSessions);
      console.log(this.sessionsInfo);
      // hide 'no sessions yet' message
      if (this.sessionsInfo.length !== 0) {
        this.s_indicatorEvent = true;
      }
    }, (error) => {
      console.log(error);
      this.alertservice.sendAlert('Sorry, can not get data now, please try again!', 'ERROR', 'toast-top-right', 5000);
    });
  }
  // tutor role: get tutor schedules
  getSchedulesInfo() {
    // get tutor schedules
    this.tutorService.showTutorSchedules().subscribe(
      (res) => {
        console.log(res);
        // this.locations = res['data'].thisTutorProfile.teaching_locations;
        let eventContainer = this.calendarService.getEvent(res['tutorFreeTime'], res['tutorSessions']);
        console.log(eventContainer);
        this.calendarEvents = eventContainer.free;
        // only after get schedules data, then show the edit button
        this.showEdit = true;
        // console.log(this.calendarEvents);
        // console.log('edit coming');
      }, (error) => {
        console.log(error);
        this.alertservice.sendAlert('Sorry, can not get data now, please try again!', 'ERROR', 'toast-top-right', 5000);
      });

  }
  // learner role: get learner sessions information
  getLearnerSessionInfo() {
    console.log('search this range:', this.range);
    this.learnerService.indexLearnerSessions(this.range).subscribe((res) => {
      console.log(res);
      let allSessions = res['allSessions'];
      console.log(allSessions);
      this.sessionsInfo = this.changeFormat(allSessions);
      console.log(this.sessionsInfo);
      // hide 'no sessions yet' message
      if (this.sessionsInfo.length !== 0) {
        this.s_indicatorEvent = true;
        this.showEdit = true;
      }
    }, (error) => {
      console.log(error);
      this.alertservice.sendAlert('Sorry, can not get data now, please try again!', 'ERROR', 'toast-top-right', 5000);
    });
  }
  // learner role: used to get a specific tutor schedules
  getInfoShedules(tutorID: string, times: any[], selectedSession: any) {
    // myEvents is the freeEvents of the tutor, and used to pass to dialog fullcalendar
    let myEvents = [];
    let myLocs = [];
    console.log('find a tutor', tutorID, this.freeEvents);
    // check if alreay have the tutor schedules
    if (this.findTutor(this.freeEvents, tutorID)) {
      console.log('found');
      myEvents = this.findTutor(this.freeEvents, tutorID)[tutorID];
      myLocs = this.findTutor(this.myLocations, tutorID)[tutorID];
      console.log(myEvents);
      console.log(myLocs);
      // pass to dialog
      this.processDialog(selectedSession, myEvents, myLocs, times, this.role);
    } else {
      // if not found, then go to server to get the data
      this.learnerService.showSchedule(tutorID).subscribe(
        (res) => {
          console.log(res);
          let loc = res['dataCon'].tutorProfile.teaching_locations;
          // store the free events into 'freeEvents' variable
          let eventContainer = this.calendarService.getEvent(res['tutorFreeTime'], res['tutorSessions']);
          let free = eventContainer.free;
          let freeObj = {};
          freeObj[tutorID] = free;
          this.freeEvents.push(freeObj);
          // store locations into 'myLocations' variable
          let locObj = {};
          locObj[tutorID] = loc;
          this.myLocations.push(locObj);
          // console.log(this.freeEvents);
          // console.log(this.myLocations);
          // update freeevents and locations
          myEvents = free;
          myLocs = loc;
          console.log(myEvents);
          console.log(myLocs);
          // pass to dialog
          this.processDialog(selectedSession, myEvents, myLocs, times, this.role);
        }, (error) => {
          console.log(error);
          this.alertservice.sendAlert('Sorry, can not get data now, please try again!', 'ERROR', 'toast-top-right', 5000);
        });
    }
  }
  // learner role: find if already get the tutor schedules from server
  findTutor(array: any[], tutorID: string) {
    for (let eventObj of array) {
      if (eventObj.hasOwnProperty(tutorID)) {
        return eventObj;
      }
    }
    return false;
  }
  // get user image url
  getURL(id: string): string {
    let imageURL = this.baseUrl + 'userimg/' + id + '-cp.jpeg';
    return imageURL;
  }
  // change sessions object to another format which sepertate the date and time
  changeFormat(fiveSessions: any) {
    let newSessions = fiveSessions.map(e => {
      let newObj = {};
      // let sessionDate = e.session_date.slice(0, 10);
      // let sessionTime = e.session_date.slice(11);
      // let date = sessionDate + 'T' + sessionTime;
      let date = this.changeToMoment(e.session_date);
      let newDate = date.format('LL');
      let startTime = date.format('LT');
      let endTime = date.add(e.session_duration, 'hours').format('LT');
      let times = this.getTimes(e);
      let day = date.format('ddd');
      let tutorID = e.tutor_id.toString();
      //let tutor_user_id = e.tutor_user_id.toString();
      let learnerID = e.learner_id.toString();
      let update: number = e.last_update_party;
      let tutor_img = this.imageService.findUserImg(tutorID);
      let learner_img = this.imageService.findUserImg(learnerID);
      // set property withinTwelveHours to be boolean
      let now = moment();
      let interval = moment.duration(date.diff(now)).asHours();
      let withinTwelveHours = false;
      if (interval <= 8) {
        withinTwelveHours = true;
      }
      //if session is passed, assign session_status is proceed!
      let session_status;

      if (this.developVersion === true)  //for develop test, in 48 hour session can be report
        session_status = (e.session_status === 0 && now > date.add(e.session_duration - 48, 'hours')) ?
          50 : e.session_status;
      else
        session_status = (e.session_status === 0 && now > date) ?
          50 : e.session_status;
      
      if (e.session_status===2 && e.ratings ===null)
        session_status = 49;

      let session_status_name;
      switch (session_status) {
        case 0:
          session_status_name = "Planned";  //action:T and L cancel
          break;
        case 1:
          session_status_name = "Canceled"; //tutor cancel or learn cancel ,action: nothing
          break;
        case 2:
          session_status_name = "Completed";//statue==2 and with rating,action: nothing
         break;
        case 3:
          session_status_name = "Dispute"; //action: nothing
          break;
        case 49:
          session_status_name = "Waiting rating";//statue==2 and without rating, action:L,rating and dispute,T ,nothing
          break;
        case 50:
          session_status_name = "Waiting report";//status==0 and session time passed,action L,nothing ,T,report and dispute
          break;
        default:
          session_status_name = "Others";
      }

      let canceled_party;
      if (session_status!=1)
        canceled_party='';
      else{
        if (e.canceled_party===1)
          canceled_party=' by tutor'
        else
          canceled_party=' by learner'
      }

      date.add(e.session_duration, 'hours')
      console.log(interval, withinTwelveHours);
      newObj = {
        session_date: newDate,
        session_startTime: startTime,
        session_endTime: endTime,
        session_id: e.session_id,
        learner_name: e.learner_first_name,
        tutor_name: e.tutor_name,
        session_subject: e.session_subject,
        session_location: e.session_location,
        session_status: session_status,
        session_times: times,
        session_day: day,
        tutor_id: tutorID,
        session_update: update,
        tutor_img: tutor_img,
        learner_img: learner_img,
        withinTwelveHours: withinTwelveHours,
        session_status_name: session_status_name,
        tutor_report: e.tutor_report,
        ratings: e.ratings,
        cancel_comment:e.cancel_comment,
        canceled_party:canceled_party,
        suggestion:e.suggestion
      };
      return newObj;
    });
    return newSessions;
  }

  // get time slots of one session
  getTimes(session: any) {
    let timesArray = [];
    let slots = session.session_duration * 2;
    let myDate = this.changeToMoment(session.session_date);
    // console.log(myDate);
    for (let i = 0; i < slots; i++) {
      timesArray.push(myDate.format().substr(0, 19));
      myDate.add(30, 'minutes');
    }
    return timesArray;
  }
  // find first after now element index
  findFirstIndex(allSessions: any) {
    let firstIndex = 0;
    for (let session of allSessions) {
      let myTime = session.session_date;
      let date = this.changeToMoment(myTime);
      if (date.isSameOrAfter(this.now)) {
        firstIndex = allSessions.indexOf(session);
        break;
      }
    }
    return firstIndex;
  }
  // get the start date and end date for get request
  getRange() {
    let range = [];
    this.now = moment();
    // two days before now, and five days after today
    let startDate = this.now.subtract(2, 'days').format().substr(0, 19);
    let endDate = this.now.add(7, 'days').format().substr(0, 19);
    range.push(startDate);
    range.push(endDate);
    // change now to original
    this.now.subtract(5, 'days');
    return range;
  }
  // update text and their color of selections
  updateText(selection: Object, sessionID: number) {
    let statusLabelID = 'label' + sessionID;
    let status = selection['s_status'];
    if (status === 'confirm') {
      $('#' + statusLabelID).html('<strong style="color: green;">Confirmed</strong>');
    } else {
      $('#' + statusLabelID).html('<strong style="color: red;">Canceled</strong>');
    }
  }
  // change time to moment object format
  changeToMoment(time: any): any {
    let sessionDate = time.slice(0, 10);
    let sessionTime = time.slice(11);
    let date = sessionDate + 'T' + sessionTime;
    // change utc to local date
    let localDate = moment.utc(date).local().format().slice(0, 19);
    return moment(localDate);
  }
  // update buttons through updating the status in sessionInfo which connected to html
  updateStatus(session: Object, mySessions: any[], sessionID: number) {
    let x = this.findSession(mySessions, Number(sessionID));
    console.log('my', x);
    x.session_status = session['s_status'] + 'ed';
  }
  // find the sessionobjec in this.SessionInfo array
  findSession(sessions: any, id: number) {
    let findedSession;
    for (let session of sessions) {
      if (session.session_id === id) {
        findedSession = session;
        break;
      }
    }
    return findedSession;
  }
  // get the session object from sessionInfo using sessionID
  getSession(allSessions: any, id: any) {
    for (let session of allSessions) {
      if (session.session_id === id) {
        return session;
      }
    }
  }
  // update this.sessionInfo
  updateSessions(sessions: any, res: any) {
    // get new session information and change its format
    // if time changed
    let id = Number(Object.getOwnPropertyNames(res)[0]);
    if (res[id].hasOwnProperty('s_date')) {
      console.log(11111111);
      let date = res[id].s_date;
      console.log(date);
      let newDate = moment(date).format('LL');
      let startTime = moment(date).format('LT');
      let duration = res[id].s_duration;
      let endTime = moment(date).add(duration, 'hours').format('LT');
      let times = [];
      let day = moment(date).format('ddd');
      for (let x of res[id].s_times) {
        let hour = x.substr(0, 2);
        let minute = x.substr(2, 2);
        let startTime = date.substr(0, 11) + hour + ':' + minute + ':00';
        times.push(startTime);
      }
      console.log(times);
      // update this.sessionInfo
      for (let session of sessions) {
        if (session.session_id === id) {
          session['session_date'] = newDate;
          session['session_endTime'] = endTime;
          session['session_startTime'] = startTime;
          // no matter, time changed or location changed, update the status
          session['session_status'] = 0;
          session['session_times'] = times;
          session['session_day'] = day;
          // add a new property to indicate that the session has been updated at least one time
          session['updated'] = 'yes';
        }
      }
    }
    // if location changed
    if (res[id].hasOwnProperty('s_location')) {
      for (let session of sessions) {
        if (session.session_id === id) {
          session['session_location'] = res[id].s_location;
        }
      }
    }
  }
  // remove cancel/confirm options
  removeOptions(res: any) {
    let id = Object.getOwnPropertyNames(res)[0];
    console.log(id);
    console.log('length', $('#act' + id).length);
    // hide cancel and confirm button if they exists
    if ($('#can' + id).length !== 0) {
      $('#can' + id).remove();
    }
    if ($('#con' + id).length !== 0) {
      $('#con' + id).remove();
    }
    $('#suc' + id).html('<p style=\'color: red;\'>New Session</p>');
  }
  addFreetimes(events: any, times: any) {
    // before add times, check if already have this events, if the user second time click edit button, it will have overlap events
    console.log(times);
    for (let time of times) {
      let exist = false;
      for (let event of events) {
        if (event.start === time) {
          exist = true;
        }
      }
      // if not exist, then add to the events
      if (!exist) {
        let endTime = moment(time).add(30, 'minutes').format().substr(0, 19);
        console.log(time, endTime);
        let myObj = {
          title: '',
          start: time,
          end: endTime,
          color: '#00ad2b'
        };
        events.push(myObj);
      }
    }
  }
  // show generate report dialog
  generateReport(event) {
    console.log('report');
    let sessionID = Number(event.srcElement.id.slice(3));
    let dialogRef = this.dialog.open(TutorReportDialogComponent,
      {
        panelClass: 'dialog1',
        // data: [1 / 1, this.profile_photo],
        disableClose: true
      });
    dialogRef.afterClosed().subscribe(
      (res) => {
        if (!res) return;
        console.log(res);
        // this.alertservice.sendAlert('This operation successed!','SUCCESS', 'toast-top-right', 1500);                                  
          // this.profile_photo = res;
          // this.submitImage(res)
        this.sendReport(sessionID, res);
      },
      (err) => {
        console.warn(err);
        this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
      }
    );
  }
  reportIssue(event) {
    console.log('report');
    let sessionID = Number(event.srcElement.id.slice(3));
    let dialogRef = this.dialog.open(ReportSessionIssueDialogComponent,
      {
        panelClass: 'dialog1',
        data: sessionID,
      });
    dialogRef.afterClosed().subscribe(
      (res) => {
        if (!res) return;
        console.log(res);
        this.alertservice.sendAlert('This operation successed!', 'SUCCESS', 'toast-top-right', 1500);
        if (res) {
          console.log('got something', res);
        }
      },
      (err) => {
        console.warn(err);
        this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
      }
    );
  }
  //send reference data to server  
  sendReference(tutorId: number, reference: object) {
    this.learnerService.storeTutorReference(tutorId, reference).subscribe(
      (res) => {
        console.log(res);
        console.log('Successfully sent reference!');
        this.showAllSessions();
        this.alertservice.sendAlert('This operation successed!', 'SUCCESS', 'toast-top-right', 1500);
      }
      , (err) => {
        console.warn(err);
        // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
        this.alertservice.serviceErrorAlert(err);
      }
    );
  }

  //send rating data to server  
  sendRating(sessionId: number, rating: object) {
    this.learnerService.storeRateSession(sessionId, rating).subscribe(
      (res) => {
        console.log(res);
        console.log('Successfully sent rating!');
        this.showAllSessions();
        this.alertservice.sendAlert('This operation successed!', 'SUCCESS', 'toast-top-right', 1500);
      }
      , (err) => {
        console.warn(err);
        // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
        this.alertservice.serviceErrorAlert(err);
      }
    );
  }
  //send report data to server
  sendReport(sessionId: number, report: object) {
    this.tutorService.storeTutorSessionReport(sessionId, report).subscribe(
      (res) => {
        console.log(res);
        console.log('Successfully sent report!');
        this.showAllSessions();
        this.alertservice.sendAlert('This operation successed!', 'SUCCESS', 'toast-top-right', 1500);
      }
      , (err) => {
        console.warn(err);
        // this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
        this.alertservice.serviceErrorAlert(err);
      }
    );
  }
  rateLesson(event, session) {
    console.log('view all session');
    let dialogRef = this.dialog.open(LearnerSessionRatingDialogComponent,
      {
        panelClass: 'dialog1',
        data: {
          tutor_name: session.tutor_name,
          tutor_img: session.tutor_img,
          session_time: session.session_startTime + "-" + session.session_endTime,
          session_date: session.session_date,
          session_location: session.session_location,
          session_id: session.session_id,
        },
      });
    dialogRef.afterClosed().subscribe(
      (res) => {
        if (!res) return;
        console.log(res);
        this.sendRating(session.session_id, res[0]);
        if (res[1].comment.length > 0)
          this.sendReference(session.tutor_id, res[1]);
      },
      (err) => {
        console.warn(err);
        this.alertservice.sendAlert('This operation failed!', 'ERROR', 'toast-top-right', 5000);
      }
    );
  }
  triggerMessenger(event) {
    let sessionID = Number(event.srcElement.id.slice(3));
    let session_inquestion = this.findSession(this.sessionsInfo, Number(sessionID));
    console.log(session_inquestion);
    // tutor role:
    if (this.role === 3) {
      let learner_id = session_inquestion.learner_id;
      this.changeValue(learner_id);
      console.log(learner_id + 'sent successfully');
    }
    // learner role:
    if (this.role === 1 || this.role === 2) {
      let tutor_id = session_inquestion.tutor_user_id;
      this.changeValue(tutor_id);
      console.log(tutor_id + 'sent successfully');
    }
  }
  // change the value in the subject behaviour
  changeValue(data: any) {
    let current = this.messengerHelperService.trigger.getValue();
    if (current === 'no') {
      this.messengerHelperService.trigger.next(data);
    } else {
      this.messengerHelperService.trigger.next('no');
    }
  }
  getPage(page, tab) {
    this.pagination[tab].currentPage = page;
  }
  getFilterSessions(filter) {
    let filterSessions;
    if (filter === 'all')
      filterSessions = this.sessionsInfo;
    else
      filterSessions = this.sessionsInfo.filter(e => { return e.session_status === filter * 1 })

    this.pagination[filter].totalPosts = filterSessions.length;
    //this.currentPage = page;
    this.pagination[filter].pageNumber = Math.ceil(filterSessions.length / this.perPage);
    this.pagination[filter].pages = [];
    if (this.pagination[filter].pageNumber > 1) {
      for (let i = 1; i < this.pagination[filter].pageNumber + 1; i++) {
        this.pagination[filter].pages.push(i);
      }
      //console.log(this.pages);
    } else {
      this.pagination[filter].pages.push(1);
    }
    return filterSessions.slice((this.pagination[filter].currentPage - 1) * this.perPage, this.pagination[filter].currentPage * this.perPage);
  }
    
}

